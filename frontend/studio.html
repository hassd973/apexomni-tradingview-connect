<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <title>QUANTUMI • BTC Hash Studio (Pro + Haptics)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0d0f12" />
    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Sixtyfour:BLED,SCAN@0..100,-53..100&family=Sora:wght@100..800&display=swap" rel="stylesheet" />
    <style>
      *, *::before, *::after { box-sizing: border-box; }
      :root{ --bg:#111215; --card:#0d0f12; --fg:#f7f7f7; --muted:#cfd3d8; --accent:#00FF7E; --border:rgba(0,255,126,.28); --soft:rgba(0,255,126,.16); --focus:#00FF7E; --danger:#ff6161; --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom); }
      [data-theme="light"]{ --bg:#ffffff; --card:#f7f8fa; --fg:#0e1116; --muted:#3a4556; --accent:#0ACF83; --border:rgba(10,207,131,.35); --soft:rgba(10,207,131,.15); }
      html,body{ height:100%; font-family:'Sora',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--fg); }
      body{ display:flex; flex-direction:column; min-height:100vh; overflow-x:hidden; }
      header{ position:sticky; top:0; z-index:40; padding-top:var(--safe-top); background:linear-gradient(180deg, rgba(17,18,21,.72), rgba(17,18,21,.38)); border-bottom:1px solid rgba(255,255,255,.08); backdrop-filter:saturate(180%) blur(18px); -webkit-backdrop-filter:saturate(180%) blur(18px); }
      [data-theme="light"] header{ background:linear-gradient(180deg, rgba(255,255,255,.82), rgba(255,255,255,.65)); border-bottom-color:#e6e8ee; }
      .brand{ display:flex; align-items:center; gap:.6rem; padding:12px 16px 10px; flex-wrap:wrap; }
      .logo{ font-family:'Sixtyfour',sans-serif; font-size:clamp(20px,4vw,32px); letter-spacing:2px; text-shadow:0 1px 6px #0006; }
      .right{ margin-left:auto; display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
      .btn{ background:#111; border:1px solid var(--accent); color:#fff; border-radius:999px; padding:10px 14px; cursor:pointer; transition:background .18s, color .18s, transform .06s; min-width:44px; min-height:44px; }
      [data-theme="light"] .btn{ background:#fff; color:#0e1116; border-color:var(--accent); }
      .btn:hover, .btn:focus{ background:var(--accent); color:#111; outline:none; }
      .btn:active{ transform: translateY(1px); }
      .icon-btn{ width:44px; height:44px; display:inline-grid; place-items:center; border-radius:12px; }
      main{ flex:1; display:grid; grid-template-columns: 1fr; gap:12px; padding:12px 14px; }
      @media (min-width:1024px){ main{ grid-template-columns: minmax(0,1fr) 360px; } }
      .panel{ background:rgba(13,15,18,.5); backdrop-filter:saturate(180%) blur(12px); -webkit-backdrop-filter:saturate(180%) blur(12px); border:1px solid rgba(255,255,255,.08); border-radius:16px; box-shadow:0 6px 28px #0006; position:relative; overflow:hidden; }
      [data-theme="light"] .panel{ background:rgba(255,255,255,.6); border-color:#e6e8ee; box-shadow:0 8px 24px rgba(16,24,40,.08); }
      #stagePanel{ min-height:62vh; }
      .stage{ position:relative; min-height:52vh; }
      canvas#btc-hash-canvas{ width:100%; height:62vh; display:block; background:#000; touch-action:none; border-radius:14px; }
      @media (max-width:640px){ canvas#btc-hash-canvas{ height:54vh; } }
      .overlay{ position:absolute; left:12px; top:12px; right:12px; display:flex; align-items:center; gap:6px; flex-wrap:wrap; z-index:10; }
      .chip{ display:flex; align-items:center; gap:6px; pointer-events:auto; background:rgba(0,0,0,.55); border:1px solid var(--border); border-radius:10px; padding:6px 8px; font-size:12px; }
      [data-theme="light"] .chip{ background:rgba(255,255,255,.8); border-color:#e6e8ee; color:#0e1116; }
      .legend{ position:absolute; left:12px; right:12px; bottom:12px; display:flex; gap:6px; flex-wrap:wrap; justify-content:center; pointer-events:none; }
      .legend .swatch{ width:12px; height:12px; border-radius:3px; margin-right:4px; border:1px solid rgba(255,255,255,.4); }
      [data-theme="light"] .legend .swatch{ border-color:#cfd3d8; }
      .aside{ display:flex; flex-direction:column; gap:10px; overflow:auto; padding:10px; scrollbar-color:#333 #111; }
      .card{ background:rgba(12,15,18,.5); backdrop-filter:saturate(160%) blur(10px); -webkit-backdrop-filter:saturate(160%) blur(10px); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:10px; }
      [data-theme="light"] .card{ background:rgba(255,255,255,.7); border-color:#e6e8ee; }
      .log{ list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:8px; }
      .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#111; border:1px solid rgba(255,255,255,.08); padding:2px 6px; border-radius:6px; font-size:11px; }
      [data-theme="light"] .kbd{ background:#f3f4f7; border-color:#e6e8ee; color:#0e1116; }
      footer{ flex-shrink:0; border-top:1px solid rgba(255,255,255,.08); background:rgba(14,17,20,.6); backdrop-filter:saturate(180%) blur(12px); -webkit-backdrop-filter:saturate(180%) blur(12px); padding:10px 14px calc(10px + var(--safe-bottom)); font-size:12px; color:#aaa; display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px; }
      [data-theme="light"] footer{ background:rgba(255,255,255,.7); border-top-color:#e6e8ee; color:#3a4556; }
      /* Controls */
      #controls-toggle{ display:inline-flex; margin:0 14px 12px; }
      .controls-rail{ padding:10px 14px 12px; flex-shrink:0; transition:max-height .25s ease; overflow:hidden; }
      .controls-rail[aria-hidden="true"]{ max-height:0; padding:0 14px; }
      .controls-rail[aria-hidden="false"]{ max-height:80vh; overflow-y:auto; padding:10px 14px 12px; }
      .controls{ width:100%; display:grid; grid-template-columns: repeat(auto-fit, minmax(240px,1fr)); gap:10px; background:rgba(20,20,20,.45); backdrop-filter:saturate(180%) blur(16px); -webkit-backdrop-filter:saturate(180%) blur(16px); border:1px solid rgba(255,255,255,.1); border-radius:16px; padding:14px; box-shadow:0 2px 20px #0006; }
      [data-theme="light"] .controls{ background:rgba(255,255,255,.7); border-color:#e6e8ee; box-shadow:none; }
      .btn-row{ display:flex; flex-wrap:wrap; gap:8px; }
      .ctrl{ width:100%; display:flex; flex-wrap:wrap; align-items:center; gap:8px; background:rgba(12,15,18,.6); backdrop-filter:saturate(160%) blur(12px); -webkit-backdrop-filter:saturate(160%) blur(12px); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px; min-height:52px; }
      [data-theme="light"] .ctrl{ background:rgba(255,255,255,.8); border-color:#e6e8ee; }
      .ctrl label{ font-size:12px; white-space:nowrap; opacity:.9; }
      .ctrl input[type="text"], .ctrl input[type="number"], .ctrl input[type="range"], .ctrl select, .ctrl input[type="email"], .ctrl input[type="file"]{ flex:1 1 auto; min-width:0; background:#000; border:1.5px solid #444; color:#fff; border-radius:8px; padding:10px; outline:none; }
      [data-theme="light"] .ctrl input, [data-theme="light"] .ctrl select{ background:#fff; color:#0e1116; border-color:#d0d5dd; }
      .ctrl input[type="range"]{ padding:0; -webkit-appearance:none; appearance:none; background:transparent; }
      .ctrl input[type="range"]::-webkit-slider-runnable-track{ height:4px; background:rgba(0,255,126,.3); border-radius:2px; }
      .ctrl input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:16px; height:16px; border-radius:50%; background:var(--accent); cursor:pointer; margin-top:-6px; }
      .ctrl input[type="range"]::-moz-range-track{ height:4px; background:rgba(0,255,126,.3); border-radius:2px; }
      .ctrl input[type="range"]::-moz-range-thumb{ width:16px; height:16px; border-radius:50%; background:var(--accent); cursor:pointer; }
      /* Fullscreen */
      .fs-target:fullscreen, .fs-target:-webkit-full-screen{ background:#000; width:100%; height:100%; }
      .fs-btn-on{ display:none; } .fs-active .fs-btn-on{ display:inline-flex; } .fs-active .fs-btn-off{ display:none; }
      /* iOS niceties */
      @supports (-webkit-touch-callout: none){ .btn { -webkit-tap-highlight-color: transparent; } }
    </style>

    <!-- three.js r128 for compatibility -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/FBXExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>
  </head>
  <body>
    <a class="skip-link" href="#main">Skip to content</a>
    <header>
      <div class="brand">
        <div class="logo">QUANTUMI</div>
        <div class="sub text-sm opacity-80">BTC Hash Studio • pro</div>
        <div class="right">
          <button id="theme-toggle" class="btn" title="Toggle light/dark">Light</button>
          <button id="btc-fullscreen-btn" class="btn" aria-label="Fullscreen">Fullscreen</button>
          <a href="https://quantumi.space" class="btn" rel="noopener">Home</a>
          <div class="sub text-xs opacity-70">v3.1</div>
        </div>
      </div>
      <button id="controls-toggle" class="btn" type="button" aria-expanded="false" aria-controls="controls-rail">Controls</button>
    </header>

    <main id="main">
      <section class="panel fs-target" id="stagePanel" aria-label="3D stage">
        <div class="stage">
          <div class="overlay" id="metrics">
            <button id="btc-mobile-fs-toggle" class="icon-btn" aria-label="Toggle mobile view">⤢</button>
            <button id="btc-zoom-out" class="icon-btn" title="Zoom out">−</button>
            <button id="btc-zoom-in" class="icon-btn" title="Zoom in">+</button>
            <button id="btc-zoom-z0" class="icon-btn" title="Front">Z0</button>
            <button id="btc-zoom-z1" class="icon-btn" title="Isometric">Z1</button>
            <button id="btc-zoom-z2" class="icon-btn" title="Top">Z2</button>
            <button id="legend-toggle" class="btn" title="Show legend">Show Legend</button>
            <button id="hash-log-toggle" class="btn" title="Show log">Show Log</button>
            <div class="chip" id="m-price">Price —</div>
            <div class="chip" id="m-change">24h —</div>
            <div class="chip" id="m-hashrate">Hashrate —</div>
            <div class="chip" id="m-diff">Difficulty —</div>
            <div class="chip" id="m-mode">Mode — Original</div>
            <div class="chip" id="m-status">Status — Init…</div>
            <button id="btc-mobile-exit" class="btn" aria-label="Close BTC view" style="margin-left:auto;">Exit</button>
          </div>
          <canvas id="btc-hash-canvas" aria-label="BTC hash visualization"></canvas>
          <div class="legend" id="legend" aria-live="polite"></div>
        </div>
      </section>

      <aside class="panel aside">
        <div class="card">
          <div class="flex items-center gap-3">
            <strong>Hash Log</strong><span class="text-gray-400">Latest 10</span>
          </div>
          <ul id="hash-log-list" class="log" aria-live="polite"></ul>
        </div>
        <div class="card text-sm text-gray-300">
          <div class="mb-1 font-semibold">Tips</div>
          <ul class="list-disc ml-5 space-y-1">
            <li>‘Original’ mapping is live market-derived (time/price/volume).</li>
            <li>Spiral/Sphere/Helix use a BTC hash (Latest/Manual/Random/Generate).</li>
            <li>Upload **FBX** up to 500 MB to blend with clouds for custom hash art.</li>
            <li>Use <b>Haptics</b> for tactile feedback on supported devices.</li>
            <li>Fullscreen rocks for demos; iOS safe-areas supported.</li>
          </ul>
        </div>
      </aside>
    </main>

    <div id="controls-rail" class="controls-rail" aria-hidden="false">
      <div class="controls">
        <div class="ctrl" title="Haptics & controller support">
          <label>Haptics</label>
          <select id="haptics-mode">
            <option value="off" selected>Off</option>
            <option value="menu">Menu clicks</option>
            <option value="full">Menu + rotation rumble</option>
          </select>
          <small class="text-gray-400 w-full">Requires a compatible device/controller. iOS: best with paired gamepad.</small>
        </div>
        <div class="ctrl" title="Upload FBX models (supports files up to 500MB).">
          <label>Upload FBX</label>
          <input type="file" id="fbx-file" accept=".fbx" />
          <div class="btn-row">
            <button class="btn" id="btn-load-fbx" title="Pick an FBX file">Load FBX</button>
            <button class="btn" id="clear-fbx">Clear</button>
          </div>
        </div>
        <div class="ctrl" title="Mapping from data to space. ‘Original’ uses time→Z, price→X, volume→Y.">
          <label>Mapping</label>
          <select id="mapping">
            <option value="original" selected>Original (Time/Price/Volume)</option>
            <option value="spiral">Spiral (time-curve)</option>
            <option value="sphere">Sphere (volatility radius)</option>
            <option value="helix">Helix (momentum tilt)</option>
          </select>
        </div>
        <div class="ctrl" title="Instances per data point.">
          <label>Density</label>
          <input type="range" id="density" min="1" max="200" value="60" />
        </div>
        <div class="ctrl" title="Point size">
          <label>Point Size</label>
          <input type="range" id="pointSize" min="0.02" max="0.6" step="0.02" value="0.12" />
        </div>
        <div class="ctrl" title="Color mode">
          <label>Theme</label>
          <select id="theme">
            <option value="original" selected>Original</option>
            <option value="heatmap">Heatmap (volatility)</option>
            <option value="lifecycle">Lifecycle (volume)</option>
          </select>
        </div>
        <div class="ctrl" title="Paste a hash, or use the latest block. Used when Mapping ≠ Original.">
          <label>Hash</label>
          <input id="hashInput" type="text" placeholder="Paste a block/tx hash…" inputmode="latin" autocomplete="off" />
          <div class="btn-row">
            <button class="btn" id="btnLatest" title="Use latest block-derived hash">Latest</button>
            <button class="btn" id="btnRandom" title="Use random hash">Random</button>
            <button class="btn" id="btnGenerate" title="Generate from price">Generate</button>
          </div>
        </div>
        <div class="ctrl" title="Export the current scene and data.">
          <label>Export</label>
          <button class="btn" id="export-fbx">FBX</button>
          <button class="btn" id="export-png">PNG</button>
          <button class="btn" id="export-csv">CSV</button>
          <button class="btn right" id="reset-view" title="Reset camera">Reset</button>
        </div>
      </div>
    </div>

    <footer>
      <span>© 2025 <span style="font-family:'Sixtyfour',sans-serif">QUANTUMI</span> — All Rights Reserved.</span>
      <a href="https://www.instagram.com/quantumi.space/" target="_blank" rel="noopener" class="text-green-500 underline">Instagram</a>
    </footer>

    <script>
      // --- Utils & globals ---------------------------------------------------
      const $ = (id) => document.getElementById(id);
      const nfUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 2 });
      const canvas = $('btc-hash-canvas');
      const MAX_FBX_SIZE = 500 * 1024 * 1024; // 500MB
      let renderer, scene, camera, controls; let dotClouds = []; let colorLegend = [];
      let instancedMesh = null; // user FBX as points

      // --- Theme toggle ------------------------------------------------------
      (function(){
        const apply = (mode) => { document.documentElement.setAttribute('data-theme', mode); $('theme-toggle').textContent = mode==='dark'?'Light':'Dark'; };
        const pref = matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        const saved = localStorage.getItem('quantumi-theme') || pref; apply(saved);
        $('theme-toggle').addEventListener('click', ()=>{ const cur=document.documentElement.getAttribute('data-theme'); const nxt=cur==='dark'?'light':'dark'; localStorage.setItem('quantumi-theme', nxt); apply(nxt); });
      })();

      // --- Colors ------------------------------------------------------------
      const themes = { original:['#00ffcc','#00ff88','#00ff44','#00ff00','#44ff00','#88ff00','#ccff00'], heatmap:['#00ff00','#ffff00','#ff0000'], lifecycle:['#3dd5ff','#00ff88','#ff8a00'] };
      function interpolateColor(c1,c2,ratio){ const hex=(c)=>parseInt(c.replace('#',''),16); const r1=(hex(c1)>>16)&255, g1=(hex(c1)>>8)&255, b1=hex(c1)&255; const r2=(hex(c2)>>16)&255, g2=(hex(c2)>>8)&255, b2=hex(c2)&255; const r=Math.round(r1+(r2-r1)*ratio), g=Math.round(g1+(g2-g1)*ratio), b=Math.round(b1+(b2-b1)*ratio); return `#${((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1)}`; }
      function themeColor(volatility, volume, minV, maxV, idx){ const t=$('theme').value; if(t==='heatmap'){ const ratio=Math.min(volatility/5,1); return interpolateColor(themes.heatmap[0],themes.heatmap[2],ratio); } if(t==='lifecycle'){ const ratio=(volume-minV)/Math.max((maxV-minV),1); return interpolateColor(themes.lifecycle[0],themes.lifecycle[2],ratio); } return themes.original[idx % themes.original.length]; }

      // --- Data fetch --------------------------------------------------------
      async function fetchJSON(url){ const r = await fetch(url); if(!r.ok) throw new Error(r.status); return r.json(); }
      async function fetchTEXT(url){ const r = await fetch(url); if(!r.ok) throw new Error(r.status); return r.text(); }
      async function fetchBTCHistorical(){ try { return await fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=1'); } catch { return null; } }
      async function fetchBTCPrice(){ try { const d=await fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin'); return { price:d.market_data.current_price.usd, volume:d.market_data.total_volume.usd }; } catch { return { price:60000, volume:4_500_000 }; } }
      async function fetchBTCHashRate(){ try { return parseFloat(await fetchTEXT('https://api.blockchain.info/q/hashrate?cors=true'))/1e9; } catch { return 0; } }
      async function fetchBTCDifficulty(){ try { return parseFloat(await fetchTEXT('https://api.blockchain.info/q/getdifficulty?cors=true')); } catch { return 0; } }

      // --- Hash helpers ------------------------------------------------------
      function generateHashFromPrice(price){ const s=String(price); let h=''; for(let i=0;i<64;i++){ h+=(s.charCodeAt(i%s.length)%16).toString(16); } return h; }
      function addHashLog(hash, time){ const el=$('hash-log-list'); const li=document.createElement('li'); li.className='card p-2'; li.innerHTML = `<div>Hash ID: ${hash}</div><div class="text-xs text-gray-400">${time}</div>`; el.prepend(li); while(el.children.length>10) el.lastChild.remove(); }
      function updateLegend(){ const el=$('legend'); el.innerHTML=''; const t=$('theme').value; let base=''; if(t==='heatmap'){ base = `<span class="chip"><span class="swatch" style="background:${themes.heatmap[0]}"></span>Low</span><span class="chip"><span class="swatch" style="background:${themes.heatmap[1]}"></span>Medium</span><span class="chip"><span class="swatch" style="background:${themes.heatmap[2]}"></span>High</span>`; } else if(t==='lifecycle'){ base = `<span class="chip"><span class="swatch" style="background:${themes.lifecycle[0]}"></span>New</span><span class="chip"><span class="swatch" style="background:${themes.lifecycle[1]}"></span>Maturing</span><span class="chip"><span class="swatch" style="background:${themes.lifecycle[2]}"></span>Old</span>`; } else { base = `<span class="chip"><span class="swatch" style="background:${themes.original[0]}"></span>Start</span><span class="chip"><span class="swatch" style="background:${themes.original[themes.original.length-1]}"></span>Fade</span>`; } const dataLegend = colorLegend.map(c=>`<span class="chip" title="Price ${nfUSD.format(c.price)} | Vol $${(c.volume/1e9).toFixed(2)}B | ${c.time}"><span class="swatch" style="background:${c.color}"></span></span>`).join(''); el.innerHTML = base + dataLegend; }

      // --- 3D init -----------------------------------------------------------
      function init3D(){
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, 1, 0.1, 3000); camera.position.set(10,10,30);
        renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, preserveDrawingBuffer:true }); renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2)); renderer.setClearColor(0x000000,1);
        const amb = new THREE.AmbientLight(0xffffff,0.65); scene.add(amb); const dir = new THREE.DirectionalLight(0xffffff,0.7); dir.position.set(6,8,12); scene.add(dir); const axes = new THREE.AxesHelper(20); scene.add(axes);
        controls = new THREE.OrbitControls(camera, renderer.domElement); controls.target.set(0,0,0); controls.enableDamping=true; controls.dampingFactor=.08; controls.autoRotate = !matchMedia('(prefers-reduced-motion: reduce)').matches; controls.autoRotateSpeed=1.4;
        resize(); const ro = new ResizeObserver(()=>resize()); ro.observe($('stagePanel')); window.addEventListener('orientationchange', ()=>setTimeout(resize,180));
        function resize(){ const rect=canvas.getBoundingClientRect(); const w=Math.max(1, rect.width), h=Math.max(1, rect.height); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
      }

      function clearClouds(){ dotClouds.forEach(c=>{ scene.remove(c); c.geometry.dispose(); c.material.dispose(); }); dotClouds=[]; if(instancedMesh){ scene.remove(instancedMesh); instancedMesh.geometry.dispose(); instancedMesh.material.dispose?.(); instancedMesh=null; } }

      async function drawOriginalFromMarket(){ const data = await fetchBTCHistorical(); if(!data) return; const prices=data.prices||[]; const volumes=data.total_volumes||[]; const timestamps=prices.map(p=>p[0]); if(prices.length<2) return; const minT=timestamps[0], maxT=timestamps[timestamps.length-1]; const minP=Math.min(...prices.map(p=>p[1])), maxP=Math.max(...prices.map(p=>p[1])); const minV=Math.min(...volumes.map(v=>v[1])), maxV=Math.max(...volumes.map(v=>v[1])); const latestPrice=prices[prices.length-1][1]; const latestVolume=volumes[volumes.length-1][1]; const recent=prices.slice(-10).map(p=>p[1]); const volatility=((Math.max(...recent)-Math.min(...recent))/latestPrice)*100; const cloudColorHex=themeColor(volatility, latestVolume, minV, maxV, dotClouds.length); const cloudColor=new THREE.Color(cloudColorHex); const pointsPer=parseInt($('density').value,10); const positions=[]; const colors=[]; for(let i=0;i<prices.length;i++){ const t=timestamps[i]; const price=prices[i][1]; const vol=volumes[i][1]; const z=((t-minT)/(maxT-minT))*20-10; const x=((price-minP)/(maxP-minP))*20-10; const y=((vol-minV)/(maxV-minV))*20-10; for(let j=0;j<pointsPer;j++){ positions.push(x+(Math.random()-.5), y+(Math.random()-.5), z+(Math.random()-.5)); colors.push(cloudColor.r, cloudColor.g, cloudColor.b); } }
        const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3)); geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3)); const mat=new THREE.PointsMaterial({ size: parseFloat($('pointSize').value), vertexColors:true, transparent:true, opacity:1 }); const cloud=new THREE.Points(geo,mat); scene.add(cloud); dotClouds.push(cloud); dotClouds.slice(0,-1).forEach(c=>c.material.opacity=Math.max(.12, c.material.opacity-.06)); const latestTime=new Date(timestamps[timestamps.length-1]).toLocaleTimeString(); colorLegend.push({ color:cloudColorHex, price:latestPrice, volume:latestVolume, time:latestTime }); updateLegend(); $('m-price').textContent=`Price — ${nfUSD.format(latestPrice)}`; $('m-hashrate').textContent=`Hashrate — ${(await fetchBTCHashRate()).toFixed(2)} EH/s`; $('m-diff').textContent=`Difficulty — ${await fetchBTCDifficulty()}`; }

      function layoutFromHash(hash, mapping){ const vals=Array.from(hash).map(ch=>parseInt(ch,16)); const N=256; const positions=[]; const colors=[]; const base = new THREE.Color(themes.original[dotClouds.length % themes.original.length]); for(let i=0;i<N;i++){ const v=vals[i % vals.length]/15; let x,y,z; if(mapping==='spiral'){ const a=i*.28, r=2+v*4; x=Math.cos(a)*r; y=Math.sin(a)*r; z=(i/N)*16-8; } else if(mapping==='sphere'){ const phi=Math.acos(1-(2*(i+.5))/N); const theta=Math.PI*(1+Math.sqrt(5))*(i+v); const R=6*(.6+.4*v); x=R*Math.sin(phi)*Math.cos(theta); y=R*Math.sin(phi)*Math.sin(theta); z=R*Math.cos(phi); } else if(mapping==='helix'){ const a=(i/N)*Math.PI*8; x=Math.cos(a)*5; y=Math.sin(a)*5; z=(i/N)*20-10+(v-.5); } else { const a=i*.28, r=2+v*4; x=Math.cos(a)*r; y=Math.sin(a)*r; z=(i/N)*16-8; } positions.push(x,y,z); colors.push(base.r,base.g,base.b); }
        const geo=new THREE.BufferGeometry(); geo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3)); geo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3)); const mat=new THREE.PointsMaterial({ size: parseFloat($('pointSize').value), vertexColors:true, transparent:true, opacity:1 }); const cloud=new THREE.Points(geo,mat); scene.add(cloud); dotClouds.push(cloud); dotClouds.slice(0,-1).forEach(c=>c.material.opacity=Math.max(.12, c.material.opacity-.06)); updateLegend(); }

      // --- FBX upload → Points ----------------------------------------------
      function buildPointsFromFBX(object){ let positions=[]; object.traverse((child)=>{ if(child.isMesh && child.geometry){ child.updateMatrixWorld(true); const geo = child.geometry.isBufferGeometry ? child.geometry : new THREE.BufferGeometry().fromGeometry(child.geometry); const pos = geo.attributes.position; if(!pos) return; const array = pos.array; for(let i=0;i<array.length;i+=3){ const v = new THREE.Vector3(array[i],array[i+1],array[i+2]); positions.push(v.x, v.y, v.z); } } }); if(!positions.length){ alert('No vertex positions found in FBX.'); return; } const pGeo=new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3)); const pMat=new THREE.PointsMaterial({ size: parseFloat($('pointSize').value) * 1.2, color: '#00ffaa' }); const pts=new THREE.Points(pGeo,pMat); pts.position.set(0,0,0); return pts; }
      function clearFBX(){ if(instancedMesh){ scene.remove(instancedMesh); instancedMesh.geometry.dispose(); instancedMesh.material.dispose?.(); instancedMesh=null; } }
      async function handleFBX(file){ if(!file) return; if(file.size > MAX_FBX_SIZE){ alert('File too large. Max 500MB.'); return; } const reader = new FileReader(); reader.onload = function(e){ try{ const loader = new THREE.FBXLoader(); const object = loader.parse(e.target.result); const pts = buildPointsFromFBX(object); if(pts){ clearFBX(); instancedMesh = pts; scene.add(instancedMesh); } }catch(err){ console.error(err); alert('Failed to load FBX.'); } }; reader.readAsArrayBuffer(file); }

      // --- Haptics & Gamepad -------------------------------------------------
      const Haptics = (()=>{
        let enabledMode = 'off';
        let lastAngle = 0; let lastRumbleAt = 0;
        /** small click */
        const tick = ()=>{ if(enabledMode==='off') return; if('vibrate' in navigator && (enabledMode==='menu' || enabledMode==='full')) navigator.vibrate(10); activePads().forEach(gp=>rumblePad(gp, 0.25, 60)); };
        /** continuous-ish rumble scaled by rotation speed */
        const rumbleFromRotation = (speed)=>{ if(enabledMode!=='full') return; const now=performance.now(); if(now-lastRumbleAt<90) return; lastRumbleAt = now; const intensity = Math.min(Math.max(speed/1.2, 0.05), 1.0); // 0..1
        if('vibrate' in navigator) navigator.vibrate([20, 40*Math.max(0,(1-intensity))]); activePads().forEach(gp=>rumblePad(gp, intensity, 120)); };
        const rumblePad = (gp, strength, duration)=>{
          try{
            const act = gp.vibrationActuator || (gp.hapticActuators && gp.hapticActuators[0]);
            if(!act) return; if(act.type && act.type.includes('dual-rumble')) act.playEffect('dual-rumble',{ duration:Math.round(duration), strongMagnitude:strength, weakMagnitude:strength*0.8 }); else if(act.pulse) act.pulse(strength, Math.round(duration));
          }catch(e){}
        };
        const activePads = ()=> Array.from(navigator.getGamepads ? navigator.getGamepads() : []).filter(Boolean);
        const setMode = (m)=> enabledMode = m || 'off';
        const menuClick = ()=> tick();
        const updateRotation = ()=>{
          if(enabledMode!=='full' || !controls) return;
          const angle = controls.getAzimuthalAngle ? controls.getAzimuthalAngle() : camera.rotation.y;
          const delta = Math.abs(angle - lastAngle); lastAngle = angle;
          // estimate deg/sec-like metric
          const speed = delta * 60; // frames ~60fps
          if(speed>0.01) rumbleFromRotation(speed);
        };
        return { setMode, menuClick, updateRotation };
      })();

      // Simple Gamepad controls mapping
      const GamepadControl = (function(){
        let rafId=null; const dead=0.18;
        const step=()=>{
          const pads = navigator.getGamepads ? navigator.getGamepads() : [];
          for(const gp of pads){ if(!gp) continue;
            // Left stick orbit
            const lx = Math.abs(gp.axes[0])>dead ? gp.axes[0] : 0; const ly = Math.abs(gp.axes[1])>dead ? gp.axes[1] : 0;
            if(controls){ controls.rotateLeft(lx*0.02); controls.rotateUp(ly*0.02); }
            // Right stick zoom (Y)
            const ry = Math.abs(gp.axes[3])>dead ? gp.axes[3] : 0; if(ry) camera.position.multiplyScalar(1+ry*0.02);
            // Buttons
            if(gp.buttons[0]?.pressed) { // A / Cross toggles legend
              toggleLegend(true);
            }
            if(gp.buttons[1]?.pressed) { // B / Circle random hash
              clickRandom(true);
            }
            if(gp.buttons[2]?.pressed) { // X / Square theme
              cycleTheme(true);
            }
            if(gp.buttons[3]?.pressed) { // Y / Triangle mapping
              cycleMapping(true);
            }
            if(gp.buttons[9]?.pressed) { // Start reset
              resetView(); Haptics.menuClick();
            }
          }
          rafId = requestAnimationFrame(step);
        };
        const start=()=>{ if(rafId) return; rafId = requestAnimationFrame(step); };
        const stop=()=>{ if(!rafId) return; cancelAnimationFrame(rafId); rafId=null; };
        window.addEventListener('gamepadconnected', start);
        window.addEventListener('gamepaddisconnected', (e)=>{ if(!navigator.getGamepads || !Array.from(navigator.getGamepads()).filter(Boolean).length) stop(); });
        return { start, stop };
      })();

      // --- Controls & wiring -------------------------------------------------
      function animate(){ requestAnimationFrame(animate); controls && controls.update(); Haptics.updateRotation(); renderer.render(scene,camera); }
      function resetView(){ camera.position.set(10,10,30); controls.target.set(0,0,0); controls.update(); }

      function toggleLegend(fromPad){ const el=$('legend'); const hidden=el.style.display==='none'; el.style.display = hidden ? '' : 'none'; $('legend-toggle').textContent = hidden? 'Hide Legend' : 'Show Legend'; if(fromPad) Haptics.menuClick(); }
      function clickRandom(fromPad){ const h = Array.from({length:64},()=>Math.floor(Math.random()*16).toString(16)).join(''); $('hashInput').value = h; if ($('mapping').value!=='original'){ clearClouds(); layoutFromHash(h, $('mapping').value); addHashLog(h.slice(0,16)+'…', new Date().toLocaleTimeString()); } if(fromPad) Haptics.menuClick(); }
      function cycleTheme(fromPad){ const t=$('theme'); t.selectedIndex = (t.selectedIndex+1)%t.options.length; t.dispatchEvent(new Event('change')); if(fromPad) Haptics.menuClick(); }
      function cycleMapping(fromPad){ const m=$('mapping'); m.selectedIndex = (m.selectedIndex+1)%m.options.length; m.dispatchEvent(new Event('change')); if(fromPad) Haptics.menuClick(); }

      document.addEventListener('DOMContentLoaded', async () => {
        // Controls drawer
        const drawerBtn = $('controls-toggle'); const rail = $('controls-rail'); if(drawerBtn && rail){ drawerBtn.addEventListener('click',()=>{ const open = drawerBtn.getAttribute('aria-expanded')==='true'; drawerBtn.setAttribute('aria-expanded', String(!open)); rail.setAttribute('aria-hidden', String(open)); Haptics.menuClick(); }); }

        // Haptics mode
        $('haptics-mode').addEventListener('change', (e)=>{ Haptics.setMode(e.target.value); Haptics.menuClick(); });

        init3D(); animate(); GamepadControl.start();
        await drawOriginalFromMarket(); $('m-status').textContent = 'Status — Ready';

        $('mapping').addEventListener('change', async (e)=>{ clearClouds(); $('m-mode').textContent = `Mode — ${e.target.value}`; if (e.target.value === 'original') await drawOriginalFromMarket(); else { const hv = $('hashInput').value.trim() || generateHashFromPrice((await fetchBTCPrice()).price); const h = hv.replace(/[^0-9a-f]/gi,'').padEnd(64,'0').slice(0,64); layoutFromHash(h, e.target.value); addHashLog(h.slice(0,16)+'…', new Date().toLocaleTimeString()); } Haptics.menuClick(); });
        $('density').addEventListener('input', async ()=>{ if ($('mapping').value==='original'){ clearClouds(); await drawOriginalFromMarket(); } });
        $('pointSize').addEventListener('input', ()=>{ dotClouds.forEach(c=>c.material.size=parseFloat($('pointSize').value)); if(instancedMesh) instancedMesh.material.size = parseFloat($('pointSize').value) * 1.2; });
        $('theme').addEventListener('change', async ()=>{ if ($('mapping').value==='original'){ clearClouds(); await drawOriginalFromMarket(); } updateLegend(); Haptics.menuClick(); });

        $('btnGenerate').addEventListener('click', async ()=>{ const { price } = await fetchBTCPrice(); const h = generateHashFromPrice(price); $('hashInput').value = h; if ($('mapping').value!=='original'){ clearClouds(); layoutFromHash(h, $('mapping').value); addHashLog(h.slice(0,16)+'…', new Date().toLocaleTimeString()); } Haptics.menuClick(); });
        $('btnRandom').addEventListener('click', ()=>{ clickRandom(false); });
        $('btnLatest').addEventListener('click', async ()=>{ const { price } = await fetchBTCPrice(); const h = generateHashFromPrice(price); $('hashInput').value = h; if ($('mapping').value!=='original'){ clearClouds(); layoutFromHash(h, $('mapping').value); addHashLog(h.slice(0,16)+'…', new Date().toLocaleTimeString()); } Haptics.menuClick(); });
        $('hashInput').addEventListener('change', ()=>{ const hv = $('hashInput').value.trim(); if (!hv) return; const h = hv.replace(/[^0-9a-f]/gi,'').padEnd(64,'0').slice(0,64); if ($('mapping').value!=='original'){ clearClouds(); layoutFromHash(h, $('mapping').value); addHashLog(h.slice(0,16)+'…', new Date().toLocaleTimeString()); } Haptics.menuClick(); });

        // Exporters
        $('export-fbx').addEventListener('click', ()=>{ const grp = new THREE.Group(); dotClouds.forEach(c=>grp.add(c.clone())); if(instancedMesh) grp.add(instancedMesh.clone()); const exporter=new THREE.FBXExporter(); const result=exporter.parse(grp); const blob=new Blob([result], { type: 'application/octet-stream' }); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='quantumi-btc.fbx'; a.click(); Haptics.menuClick(); });
        $('export-png').addEventListener('click', ()=>{ const oldPR=renderer.getPixelRatio(); renderer.setPixelRatio(2); renderer.render(scene,camera); const a=document.createElement('a'); a.href=renderer.domElement.toDataURL('image/png'); a.download='quantumi-btc.png'; a.click(); renderer.setPixelRatio(oldPR); Haptics.menuClick(); });
        $('export-csv').addEventListener('click', ()=>{ const rows=['x,y,z']; dotClouds.forEach(c=>{ const pos=c.geometry.getAttribute('position'); for(let i=0;i<pos.count;i++){ rows.push(`${pos.getX(i)},${pos.getY(i)},${pos.getZ(i)}`); } }); const blob=new Blob([rows.join('
')], {type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='quantumi-btc.csv'; a.click(); Haptics.menuClick(); });
        $('reset-view').addEventListener('click', ()=>{ resetView(); Haptics.menuClick(); });

        // Legend + Log toggles
        $('legend-toggle').addEventListener('click', ()=> toggleLegend(false));
        $('hash-log-toggle').addEventListener('click', ()=>{ const el=$('hash-log-list'); const hidden=el.style.display==='none'; el.style.display = hidden ? '' : 'none'; $('hash-log-toggle').textContent = hidden? 'Hide Log' : 'Show Log'; Haptics.menuClick(); });

        // FBX upload
        $('btn-load-fbx').addEventListener('click', ()=> { $('fbx-file').click(); Haptics.menuClick(); });
        $('clear-fbx').addEventListener('click', ()=>{ clearFBX(); Haptics.menuClick(); });
        $('fbx-file').addEventListener('change', (e)=> handleFBX(e.target.files[0]));

        // Zoom buttons
        $('btc-zoom-in').addEventListener('click', ()=>{ camera.position.multiplyScalar(0.9); Haptics.menuClick(); });
        $('btc-zoom-out').addEventListener('click', ()=>{ camera.position.multiplyScalar(1.1); Haptics.menuClick(); });
        $('btc-zoom-z0').addEventListener('click', ()=>{ camera.position.set(0,0,30); controls.target.set(0,0,0); Haptics.menuClick(); });
        $('btc-zoom-z1').addEventListener('click', ()=>{ camera.position.set(20,20,20); controls.target.set(0,0,0); Haptics.menuClick(); });
        $('btc-zoom-z2').addEventListener('click', ()=>{ camera.position.set(0,30,0.01); controls.target.set(0,0,0); Haptics.menuClick(); });

        // Fullscreen / mobile
        const isFS = () => document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
        const requestFS = (el) => (el.requestFullscreen||el.webkitRequestFullscreen||el.msRequestFullscreen)?.call(el);
        const exitFS = () => (document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen)?.call(document);
        const updateFS = () => { const on = !!isFS(); $('btc-fullscreen-btn').textContent = on ? 'Exit Fullscreen' : 'Fullscreen'; canvas.classList.toggle('fs-active', on); };
        $('btc-fullscreen-btn').addEventListener('click', ()=>{ if (window.innerWidth <= 640) { document.body.classList.toggle('mobile-open'); } else { if(!isFS()) requestFS(canvas); else exitFS(); } Haptics.menuClick(); });
        $('btc-mobile-fs-toggle').addEventListener('click', ()=>{ document.body.classList.toggle('mobile-open'); Haptics.menuClick(); });
        $('btc-mobile-exit').addEventListener('click', ()=>{ document.body.classList.remove('mobile-open'); Haptics.menuClick(); });
        document.addEventListener('fullscreenchange', updateFS);

        // Metrics boot
        try{ const d=await fetchBTCPrice(); $('m-price').textContent=`Price — ${nfUSD.format(d.price)}`; const hr=await fetchBTCHashRate(); $('m-hashrate').textContent=`Hashrate — ${hr.toFixed(2)} EH/s`; const df=await fetchBTCDifficulty(); $('m-diff').textContent=`Difficulty — ${df.toLocaleString()}`; $('m-change').textContent = '24h — live'; }catch{}
      });
    </script>
  </body>
</html>
